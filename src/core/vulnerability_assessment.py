from dataclasses import dataclass
from enum import Enum
from typing import List, Dict, Optional
import json
import os

class RiskLevel(Enum):
    CRITICAL = 5  # 严重
    HIGH = 4      # 高危
    MEDIUM = 3    # 中危
    LOW = 2       # 低危
    INFO = 1      # 信息

@dataclass
class VulnImpact:
    confidentiality: float  # 机密性影响
    integrity: float       # 完整性影响
    availability: float    # 可用性影响
    scope: float          # 影响范围

@dataclass
class VulnMetrics:
    attack_vector: float    # 攻击向量复杂度
    attack_complexity: float # 攻击复杂度
    privileges_required: float # 所需权限
    user_interaction: float   # 用户交互
    exploit_maturity: float   # 利用成熟度

@dataclass
class Vulnerability:
    id: str
    name: str
    type: str
    description: str
    risk_level: RiskLevel
    cvss_score: float
    impact: VulnImpact
    metrics: VulnMetrics
    affected_urls: List[str]
    remediation: List[str]
    references: List[str]

class VulnerabilityAssessor:
    def __init__(self):
        self.vuln_db = self._load_vuln_database()
        
    def _load_vuln_database(self) -> Dict:
        """加载漏洞数据库"""
        db_path = os.path.join(os.path.dirname(__file__), 'data/vuln_db.json')
        if os.path.exists(db_path):
            with open(db_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
        
    def assess_vulnerability(self, scan_result: Dict) -> List[Vulnerability]:
        """评估扫描结果中的漏洞"""
        vulnerabilities = []
        
        if not scan_result:
            return vulnerabilities
            
        # 分析注入点
        for injection_point in scan_result.get('injection_points', []):
            vuln_type = injection_point.get('type')
            if not vuln_type:
                continue
                
            # 获取漏洞基本信息
            vuln_info = self.vuln_db.get(vuln_type, {})
            if not vuln_info:
                continue
                
            # 计算CVSS分数
            cvss_score = self._calculate_cvss_score(injection_point, vuln_info)
            
            # 确定风险等级
            risk_level = self._determine_risk_level(cvss_score)
            
            # 评估影响
            impact = self._assess_impact(injection_point, vuln_info)
            
            # 评估攻击指标
            metrics = self._assess_metrics(injection_point, vuln_info)
            
            # 生成修复建议
            remediation = self._generate_remediation(vuln_type, injection_point)
            
            vulnerability = Vulnerability(
                id=f"VULN-{len(vulnerabilities)+1}",
                name=vuln_info.get('name', vuln_type),
                type=vuln_type,
                description=vuln_info.get('description', ''),
                risk_level=risk_level,
                cvss_score=cvss_score,
                impact=impact,
                metrics=metrics,
                affected_urls=[injection_point.get('url', '')],
                remediation=remediation,
                references=vuln_info.get('references', [])
            )
            
            vulnerabilities.append(vulnerability)
            
        return vulnerabilities
        
    def _calculate_cvss_score(self, injection_point: Dict, vuln_info: Dict) -> float:
        """计算CVSS分数"""
        base_score = vuln_info.get('base_cvss', 0.0)
        
        # 根据实际情况调整分数
        modifiers = 0.0
        
        # 检查是否需要认证
        if injection_point.get('requires_auth'):
            modifiers -= 0.5
            
        # 检查是否有WAF
        if injection_point.get('has_waf'):
            modifiers -= 0.3
            
        # 检查是否有数据库写入权限
        if injection_point.get('has_write_permission'):
            modifiers += 0.5
            
        final_score = base_score + modifiers
        return max(0.0, min(10.0, final_score))
        
    def _determine_risk_level(self, cvss_score: float) -> RiskLevel:
        """根据CVSS分数确定风险等级"""
        if cvss_score >= 9.0:
            return RiskLevel.CRITICAL
        elif cvss_score >= 7.0:
            return RiskLevel.HIGH
        elif cvss_score >= 4.0:
            return RiskLevel.MEDIUM
        elif cvss_score >= 0.1:
            return RiskLevel.LOW
        return RiskLevel.INFO
        
    def _assess_impact(self, injection_point: Dict, vuln_info: Dict) -> VulnImpact:
        """评估漏洞影响"""
        return VulnImpact(
            confidentiality=vuln_info.get('impact', {}).get('confidentiality', 0.0),
            integrity=vuln_info.get('impact', {}).get('integrity', 0.0),
            availability=vuln_info.get('impact', {}).get('availability', 0.0),
            scope=vuln_info.get('impact', {}).get('scope', 0.0)
        )
        
    def _assess_metrics(self, injection_point: Dict, vuln_info: Dict) -> VulnMetrics:
        """评估攻击指标"""
        return VulnMetrics(
            attack_vector=vuln_info.get('metrics', {}).get('attack_vector', 0.0),
            attack_complexity=vuln_info.get('metrics', {}).get('attack_complexity', 0.0),
            privileges_required=vuln_info.get('metrics', {}).get('privileges_required', 0.0),
            user_interaction=vuln_info.get('metrics', {}).get('user_interaction', 0.0),
            exploit_maturity=vuln_info.get('metrics', {}).get('exploit_maturity', 0.0)
        )
        
    def _generate_remediation(self, vuln_type: str, injection_point: Dict) -> List[str]:
        """生成修复建议"""
        remediation = []
        
        # 获取通用修复建议
        general_fixes = self.vuln_db.get(vuln_type, {}).get('remediation', [])
        remediation.extend(general_fixes)
        
        # 根据具体情况生成针对性建议
        if injection_point.get('parameter'):
            remediation.append(
                f"对参数 '{injection_point['parameter']}' 进行输入验证和过滤"
            )
            
        if injection_point.get('dbms'):
            remediation.append(
                f"使用 {injection_point['dbms']} 的参数化查询来防止SQL注入"
            )
            
        return remediation 