from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import json

class RiskLevel(Enum):
    CRITICAL = "严重"
    HIGH = "高危"
    MEDIUM = "中危"
    LOW = "低危"
    INFO = "信息"

@dataclass
class VulnerabilityInfo:
    type: str
    risk_level: RiskLevel
    description: str
    impact: str
    remediation: str
    references: List[str]

class VulnerabilityAnalyzer:
    def __init__(self):
        self.risk_rules = self._load_risk_rules()
        self.fix_suggestions = self._load_fix_suggestions()
        
    def _load_risk_rules(self) -> Dict:
        """加载风险评估规则"""
        # TODO: 从配置文件加载规则
        return {
            "sql_injection": {
                "risk_level": RiskLevel.CRITICAL,
                "impact_factors": ["数据库类型", "权限级别", "是否可写"],
                "weight": 10
            },
            "blind_sql_injection": {
                "risk_level": RiskLevel.HIGH,
                "impact_factors": ["响应时间", "数据库类型"],
                "weight": 8
            },
            "error_based": {
                "risk_level": RiskLevel.HIGH,
                "impact_factors": ["错误信息", "数据库类型"],
                "weight": 7
            }
        }
        
    def _load_fix_suggestions(self) -> Dict:
        """加载修复建议"""
        # TODO: 从配置文件加载建议
        return {
            "sql_injection": [
                {
                    "title": "使用参数化查询",
                    "description": "使用预编译语句和参数化查询来防止SQL注入",
                    "code_example": """
                    # 不安全的方式
                    query = f"SELECT * FROM users WHERE id = {user_id}"
                    
                    # 安全的方式
                    query = "SELECT * FROM users WHERE id = ?"
                    cursor.execute(query, (user_id,))
                    """
                },
                {
                    "title": "输入验证",
                    "description": "对所有用户输入进行严格的类型检查和格式验证",
                    "code_example": """
                    def validate_user_id(user_id):
                        if not user_id.isdigit():
                            raise ValueError("Invalid user ID")
                        return int(user_id)
                    """
                }
            ]
        }
        
    def analyze_vulnerability(self, scan_result: Dict) -> List[VulnerabilityInfo]:
        """分析扫描结果中的漏洞"""
        vulnerabilities = []
        
        if not scan_result:
            return vulnerabilities
            
        # 分析注入点
        if "injection_points" in scan_result:
            for point in scan_result["injection_points"]:
                vuln_type = point.get("type", "unknown")
                if vuln_type in self.risk_rules:
                    rule = self.risk_rules[vuln_type]
                    
                    # 评估风险等级
                    risk_level = rule["risk_level"]
                    impact = self._evaluate_impact(point, rule["impact_factors"])
                    
                    # 获取修复建议
                    remediation = self._get_remediation(vuln_type)
                    
                    vulnerabilities.append(VulnerabilityInfo(
                        type=vuln_type,
                        risk_level=risk_level,
                        description=point.get("details", ""),
                        impact=impact,
                        remediation=remediation,
                        references=point.get("references", [])
                    ))
                    
        return vulnerabilities
        
    def _evaluate_impact(self, point: Dict, factors: List[str]) -> str:
        """评估漏洞影响"""
        impact = []
        
        for factor in factors:
            if factor == "数据库类型":
                db_type = point.get("dbms", "unknown")
                impact.append(f"影响的数据库类型: {db_type}")
            elif factor == "权限级别":
                if point.get("is_admin", False):
                    impact.append("具有管理员权限")
            elif factor == "是否可写":
                if point.get("is_writable", False):
                    impact.append("可以写入文件系统")
            elif factor == "响应时间":
                if point.get("response_time", 0) > 5:
                    impact.append("响应时间较长，可能影响服务性能")
                    
        return "\n".join(impact) if impact else "影响程度未知"
        
    def _get_remediation(self, vuln_type: str) -> str:
        """获取修复建议"""
        if vuln_type in self.fix_suggestions:
            suggestions = self.fix_suggestions[vuln_type]
            result = []
            
            for suggestion in suggestions:
                result.append(f"建议: {suggestion['title']}")
                result.append(f"描述: {suggestion['description']}")
                result.append("示例代码:")
                result.append(suggestion['code_example'])
                
            return "\n".join(result)
            
        return "暂无具体修复建议"
        
    def compare_results(self, old_result: Dict, new_result: Dict) -> Dict:
        """比较两次扫描结果"""
        comparison = {
            'new_vulnerabilities': [],
            'fixed_vulnerabilities': [],
            'unchanged_vulnerabilities': []
        }
        
        old_vulns = self._extract_vulnerabilities(old_result)
        new_vulns = self._extract_vulnerabilities(new_result)
        
        # 找出新增的漏洞
        for vuln in new_vulns:
            if vuln not in old_vulns:
                comparison['new_vulnerabilities'].append(vuln)
                
        # 找出修复的漏洞
        for vuln in old_vulns:
            if vuln not in new_vulns:
                comparison['fixed_vulnerabilities'].append(vuln)
                
        # 找出未修复的漏洞
        for vuln in new_vulns:
            if vuln in old_vulns:
                comparison['unchanged_vulnerabilities'].append(vuln)
                
        return comparison
        
    def _extract_vulnerabilities(self, result: Dict) -> List[Dict]:
        """从扫描结果中提取漏洞信息"""
        vulns = []
        if result and "injection_points" in result:
            for point in result["injection_points"]:
                vulns.append({
                    'type': point.get('type'),
                    'parameter': point.get('parameter'),
                    'details': point.get('details')
                })
        return vulns
        
    def generate_report(self, vulnerabilities: List[VulnerabilityInfo]) -> str:
        """生成分析报告"""
        report = ["# 漏洞分析报告\n"]
        
        # 按风险等级分组
        risk_groups = {}
        for vuln in vulnerabilities:
            if vuln.risk_level not in risk_groups:
                risk_groups[vuln.risk_level] = []
            risk_groups[vuln.risk_level].append(vuln)
            
        # 生成报告内容
        for risk_level in RiskLevel:
            if risk_level in risk_groups:
                vulns = risk_groups[risk_level]
                report.append(f"\n## {risk_level.value}级漏洞 ({len(vulns)}个)\n")
                
                for vuln in vulns:
                    report.append(f"### {vuln.type}\n")
                    report.append(f"描述: {vuln.description}\n")
                    report.append(f"影响: \n{vuln.impact}\n")
                    report.append(f"修复建议: \n{vuln.remediation}\n")
                    if vuln.references:
                        report.append("参考链接:")
                        for ref in vuln.references:
                            report.append(f"- {ref}")
                        report.append("")
                        
        return "\n".join(report) 